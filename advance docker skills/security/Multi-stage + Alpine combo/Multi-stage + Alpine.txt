Multi-stage + Alpine combo 

If you use Multi-stage + Alpine combo, then your final image is tiny and secure.

ğŸ”¹ What is Multi-stage + Alpine combo?
Multi-stage builds: Split your Dockerfile into multiple stages â€”

1. Build stage â†’ Install heavy tools (compilers, dependencies).
2. Final stage â†’ Copy only the built app into a clean, minimal image.

Alpine base image: Lightweight Linux distro (~5 MB).
âš¡ When combined, your image size shrinks drastically.

Example:

# ---------- Build Stage ----------
FROM golang:1.21-alpine AS builder

# Set working dir
WORKDIR /app

# Copy and download dependencies
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the app
RUN go build -o myapp

# ---------- Final Stage ----------
FROM alpine:3.19

# Create non-root user for security
RUN adduser -D appuser

# Set working dir
WORKDIR /home/appuser

# Copy only the built binary from builder
COPY --from=builder /app/myapp .

# Use non-root user
USER appuser

# Run the app
CMD ["./myapp"]


ğŸ”¹ Why this is powerful?
âœ… Small size â€“ Final image has only alpine + compiled binary (no compilers, no Go toolchain).
âœ… Security â€“ Runs as non-root.
âœ… Performance â€“ Less attack surface & faster pulls/deploys.

âš–ï¸ Example Image Size Difference
golang:1.21 (full image) â†’ ~1 GB
golang:1.21-alpine â†’ ~300 MB
multi-stage + alpine final â†’ ~15 MB 